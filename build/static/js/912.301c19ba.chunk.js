(self.webpackChunketh_zurich=self.webpackChunketh_zurich||[]).push([[912,992],{44879:(t,e,i)=>{"use strict";i.d(e,{v:()=>a});var n=i(16254),o=i(27994),r=i.n(o);class a extends n.BaseAdapter{async init(t){this.chainConfig||(this.chainConfig=(0,n.getChainConfig)(n.CHAIN_NAMESPACES.SOLANA,1))}async authenticateUser(){if(!this.provider||this.status!==n.ADAPTER_STATUS.CONNECTED)throw n.WalletLoginError.notConnectedError();const{chainNamespace:t,chainId:e}=this.chainConfig,i=await this.provider.request({method:"getAccounts"});if(i&&i.length>0){const o=(0,n.getSavedToken)(i[0],this.name);if(o){if(!(0,n.checkIfTokenIsExpired)(o))return{idToken:o}}const a={domain:window.location.origin,uri:window.location.href,address:i[0],chainId:parseInt(e,16),version:"1",nonce:Math.random().toString(36).slice(2),issuedAt:(new Date).toISOString()},s=await(0,n.signChallenge)(a,t),c=(new TextEncoder).encode(s),h=await this.provider.request({method:"signMessage",params:{message:c,display:"utf8"}}),l=await(0,n.verifySignedChallenge)(t,r().encode(h),s,this.name,this.sessionTime,this.clientId,this.web3AuthNetwork);return(0,n.saveToken)(i[0],this.name,l),{idToken:l}}throw n.WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first")}async disconnectSession(){super.checkDisconnectionRequirements();const t=await this.provider.request({method:"getAccounts"});t&&t.length>0&&(0,n.clearToken)(t[0],this.name)}async disconnect(){this.rehydrated=!1,this.emit(n.ADAPTER_EVENTS.DISCONNECTED)}}},76392:(t,e,i)=>{"use strict";i.r(e),i.d(e,{PhantomAdapter:()=>c});var n=i(20240),o=i(16254),r=i(44879),a=i(47703);function s(t,e,i){return new Promise(((n,o)=>{i>0?setTimeout((async()=>{const r=await t();r&&n(r),r||s(t,e,i-1).then((t=>(n(t),t))).catch((t=>o(t)))}),e):n(!1)}))}class c extends r.v{constructor(){super(...arguments),(0,n.Z)(this,"name",o.WALLET_ADAPTERS.PHANTOM),(0,n.Z)(this,"adapterNamespace",o.ADAPTER_NAMESPACES.SOLANA),(0,n.Z)(this,"currentChainNamespace",o.CHAIN_NAMESPACES.SOLANA),(0,n.Z)(this,"type",o.ADAPTER_CATEGORY.EXTERNAL),(0,n.Z)(this,"status",o.ADAPTER_STATUS.NOT_READY),(0,n.Z)(this,"_wallet",null),(0,n.Z)(this,"phantomProvider",null),(0,n.Z)(this,"_onDisconnect",(()=>{this._wallet&&(this._wallet.off("disconnect",this._onDisconnect),this.rehydrated=!1,this.status=this.status===o.ADAPTER_STATUS.CONNECTED?o.ADAPTER_STATUS.READY:o.ADAPTER_STATUS.NOT_READY,this.emit(o.ADAPTER_EVENTS.DISCONNECTED))}))}get isWalletConnected(){var t;return!(null===(t=this._wallet)||void 0===t||!t.isConnected||this.status!==o.ADAPTER_STATUS.CONNECTED)}get provider(){var t;return(null===(t=this.phantomProvider)||void 0===t?void 0:t.provider)||null}set provider(t){throw new Error("Not implemented")}async init(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(await super.init(t),super.checkInitializationRequirements(),this._wallet=await async function(){var t;let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{interval:1e3,count:3};if("undefined"!==typeof window&&null!==(t=window.solana)&&void 0!==t&&t.isPhantom)return window.solana;const i=await s((()=>{var t;return null===(t=window.solana)||void 0===t?void 0:t.isPhantom}),e.interval,e.count);return i?window.solana:null}({interval:500,count:3}),!this._wallet)throw o.WalletInitializationError.notInstalled();this.phantomProvider=new a.PhantomInjectedProvider({config:{chainConfig:this.chainConfig}}),this.status=o.ADAPTER_STATUS.READY,this.emit(o.ADAPTER_EVENTS.READY,o.WALLET_ADAPTERS.PHANTOM);try{o.log.debug("initializing phantom adapter"),t.autoConnect&&(this.rehydrated=!0,await this.connect())}catch(e){o.log.error("Failed to connect with cached phantom provider",e),this.emit("ERRORED",e)}}async connect(){var t=this;try{if(super.checkConnectionRequirements(),this.status=o.ADAPTER_STATUS.CONNECTING,this.emit(o.ADAPTER_EVENTS.CONNECTING,{adapter:o.WALLET_ADAPTERS.PHANTOM}),!this._wallet)throw o.WalletInitializationError.notInstalled();if(this._wallet.isConnected)await this.connectWithProvider(this._wallet);else{const i=this._wallet._handleDisconnect;try{await new Promise(((e,n)=>{this._wallet?(this._wallet.once("connect",(async()=>{await this.connectWithProvider(this._wallet),e(this.provider)})),this._wallet._handleDisconnect=function(){n(o.WalletInitializationError.windowClosed());for(var e=arguments.length,r=new Array(e),a=0;a<e;a++)r[a]=arguments[a];return i.apply(t._wallet,r)},this._wallet.connect().catch((t=>{n(t)}))):n(o.WalletInitializationError.notInstalled())}))}catch(e){if(e instanceof o.Web3AuthError)throw e;throw o.WalletLoginError.connectionError(null===e||void 0===e?void 0:e.message)}finally{this._wallet._handleDisconnect=i}}if(!this._wallet.publicKey)throw o.WalletLoginError.connectionError();return this._wallet.on("disconnect",this._onDisconnect),this.provider}catch(e){throw this.status=o.ADAPTER_STATUS.READY,this.rehydrated=!1,this.emit(o.ADAPTER_EVENTS.ERRORED,e),e}}async disconnect(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{cleanup:!1};await super.disconnectSession();try{var e;await(null===(e=this._wallet)||void 0===e?void 0:e.disconnect()),t.cleanup&&(this.status=o.ADAPTER_STATUS.NOT_READY,this.phantomProvider=null,this._wallet=null),await super.disconnect()}catch(i){this.emit(o.ADAPTER_EVENTS.ERRORED,o.WalletLoginError.disconnectionError(null===i||void 0===i?void 0:i.message))}}async getUserInfo(){if(!this.isWalletConnected)throw o.WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async connectWithProvider(t){if(!this.phantomProvider)throw o.WalletLoginError.connectionError("No phantom provider");return await this.phantomProvider.setupProvider(t),this.status=o.ADAPTER_STATUS.CONNECTED,this.emit(o.ADAPTER_EVENTS.CONNECTED,{adapter:o.WALLET_ADAPTERS.PHANTOM,reconnected:this.rehydrated}),this.provider}}},7420:()=>{},95856:()=>{},78848:()=>{}}]);
//# sourceMappingURL=912.301c19ba.chunk.js.map